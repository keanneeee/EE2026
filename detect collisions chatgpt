module collision_detection_test(
    input basys_clock,
    input [7:0] x_centre_P1, y_centre_P1, 
    input [7:0] x_centre_P2, y_centre_P2,
    input [7:0] ball_x, ball_y,
    input [4:0] initial_d_P1, initial_d_P2, initial_d_ball,
    input [4:0] initial_p_P1, initial_p_P2, initial_p_ball,
    input [7:0] P1_radius, P2_radius, ball_radius,
    output reg [4:0] resultant_d_P1, resultant_d_P2, resultant_d_ball, 
    output reg [4:0] resultant_p_P1, resultant_p_P2, resultant_p_ball,
    output reg [2:0] collision_detected
);

// Temporary variables for collision checks
reg [15:0] distance_squared_P1_P2, distance_squared_P1_ball, distance_squared_P2_ball;
reg [15:0] combined_radii_squared_P1_P2, combined_radii_squared_P1_ball, combined_radii_squared_P2_ball;

// Function to calculate reflection based on point of contact and initial direction
function [4:0] reflect_direction;
    input [4:0] initial_direction;
    input [4:0] point_of_contact;
    case (point_of_contact)
        0: reflect_direction = (16 - initial_direction) % 16; // East POC
        4: reflect_direction = (16 - initial_direction + 8) % 16; // North POC
        8: reflect_direction = (initial_direction + 8) % 16; // West POC
        12: reflect_direction = (initial_direction + 8) % 16; // South POC
        default: reflect_direction = initial_direction; // Default case, no change
    endcase
endfunction

// Function to calculate POC based on x and y differences
function [4:0] get_point_of_contact;
    input signed [8:0] dx, dy;
    if (dx == 0) get_point_of_contact = (dy > 0) ? 4 : 12; // Directly North or South
    else if (dy == 0) get_point_of_contact = (dx > 0) ? 0 : 8; // Directly East or West
    else begin
        if (dx > 0 && dy > 0) get_point_of_contact = 2; // NE
        else if (dx < 0 && dy > 0) get_point_of_contact = 6; // NW
        else if (dx < 0 && dy < 0) get_point_of_contact = 10; // SW
        else get_point_of_contact = 14; // SE
    end
endfunction

always @(posedge basys_clock) begin
    collision_detected <= 3'b000;

    // Initialize to default initial values
    resultant_d_P1 <= initial_d_P1;
    resultant_d_P2 <= initial_d_P2;
    resultant_d_ball <= initial_d_ball;
    resultant_p_P1 <= initial_p_P1;
    resultant_p_P2 <= initial_p_P2;
    resultant_p_ball <= initial_p_ball;

    // Calculate squared distances
    distance_squared_P1_P2 <= (x_centre_P1 - x_centre_P2) * (x_centre_P1 - x_centre_P2) +
                              (y_centre_P1 - y_centre_P2) * (y_centre_P1 - y_centre_P2);
    distance_squared_P1_ball <= (x_centre_P1 - ball_x) * (x_centre_P1 - ball_x) +
                                (y_centre_P1 - ball_y) * (y_centre_P1 - ball_y);
    distance_squared_P2_ball <= (x_centre_P2 - ball_x) * (x_centre_P2 - ball_x) +
                                (y_centre_P2 - ball_y) * (y_centre_P2 - ball_y);

    // Calculate combined radii
    combined_radii_squared_P1_P2 <= (P1_radius + P2_radius) * (P1_radius + P2_radius);
    combined_radii_squared_P1_ball <= (P1_radius + ball_radius) * (P1_radius + ball_radius);
    combined_radii_squared_P2_ball <= (P2_radius + ball_radius) * (P2_radius + ball_radius);

    // Collision Scenarios

    // P1 hits P2
    if (distance_squared_P1_P2 <= combined_radii_squared_P1_P2) begin
        collision_detected[0] <= 1;
        if (initial_p_P1 > initial_p_P2) begin
            resultant_p_P2 <= (initial_p_P1 + initial_p_P2) / 2;
            resultant_p_P1 <= (initial_p_P1 + initial_p_P2) / 2;
            resultant_d_P2 <= (get_point_of_contact(x_centre_P2 - x_centre_P1, y_centre_P2 - y_centre_P1) + 8) % 16;
            resultant_d_P1 <= reflect_direction(initial_d_P1, get_point_of_contact(x_centre_P2 - x_centre_P1, y_centre_P2 - y_centre_P1));
        end
    end

    // P2 hits P1
    if (distance_squared_P1_P2 <= combined_radii_squared_P1_P2) begin
        collision_detected[1] <= 1;
        if (initial_p_P2 > initial_p_P1) begin
            resultant_p_P1 <= (initial_p_P1 + initial_p_P2) / 2;
            resultant_p_P2 <= (initial_p_P1 + initial_p_P2) / 2;
            resultant_d_P1 <= (get_point_of_contact(x_centre_P1 - x_centre_P2, y_centre_P1 - y_centre_P2) + 8) % 16;
            resultant_d_P2 <= reflect_direction(initial_d_P2, get_point_of_contact(x_centre_P1 - x_centre_P2, y_centre_P1 - y_centre_P2));
        end
    end

    // P1 hits Ball
    if (distance_squared_P1_ball <= combined_radii_squared_P1_ball) begin
        collision_detected[2] <= 1;
        if (initial_p_P1 > initial_p_ball) begin
            resultant_p_ball <= (initial_p_P1 + initial_p_ball) / 2;
            resultant_p_P1 <= (initial_p_P1 + initial_p_ball) / 2;
            resultant_d_ball <= (get_point_of_contact(ball_x - x_centre_P1, ball_y - y_centre_P1) + 8) % 16;
            resultant_d_P1 <= reflect_direction(initial_d_P1, get_point_of_contact(ball_x - x_centre_P1, ball_y - y_centre_P1));
        end
    end

    // Ball hits P1
    if (distance_squared_P1_ball <= combined_radii_squared_P1_ball) begin
        collision_detected[2] <= 1;
        if (initial_p_ball > initial_p_P1) begin
            resultant_p_P1 <= (initial_p_P1 + initial_p_ball) / 2;
            resultant_p_ball <= (initial_p_P1 + initial_p_ball) / 2;
            resultant_d_P1 <= (get_point_of_contact(x_centre_P1 - ball_x, y_centre_P1 - ball_y) + 8) % 16;
            resultant_d_ball <= reflect_direction(initial_d_ball, get_point_of_contact(x_centre_P1 - ball_x, y_centre_P1 - ball_y));
        end
    end

    // P2 hits Ball
    if (distance_squared_P2_ball <= combined_radii_squared_P2_ball) begin
        collision_detected[2] <= 1;
        if (initial_p_P2 > initial_p_ball) begin
            resultant_p_ball <= (initial_p_P2 + initial_p_ball) / 2;
            resultant_p_P2 <= (initial_p_P2 + initial_p_ball) / 2;
            resultant_d_ball <= (get_point_of_contact(ball_x - x_centre_P2, ball_y - y_centre_P2) + 8) % 16;
            resultant_d_P2 <= reflect_direction(initial_d_P2, get_point_of_contact(ball_x - x_centre_P2, ball_y - y_centre_P2));
        end
    end

    // Ball hits P2
    if (distance_squared_P2_ball <= combined_radii_squared_P2_ball) begin
        collision_detected[2] <= 1;
        if (initial_p_ball > initial_p_P2) begin
            resultant_p_P2 <= (initial_p_P2 + initial_p_ball) / 2;
            resultant_p_ball <= (initial_p_P2 + initial_p_ball) / 2;
            resultant_d_P2 <= (get_point_of_contact(x_centre_P2 - ball_x, y_centre_P2 - ball_y) + 8) % 16;
            resultant_d_ball <= reflect_direction(initial_d_ball, get_point_of_contact(x_centre_P2 - ball_x, y_centre_P2 - ball_y));
        end
    end
end

endmodule



// back up back up plan, not exactly working but somethings diff when the 2 players touching each other
module collision_detection_test(
    input basys_clock,
    input [7:0] x_centre_P1, y_centre_P1, 
    input [7:0] x_centre_P2, y_centre_P2,
    input [4:0] initial_direction_P1, initial_direction_P2, 
    input [4:0] initial_power_P1, initial_power_P2, 
    input [7:0] P1_radius, P2_radius, 
    output reg [4:0] resultant_d_P1, resultant_d_P2, 
    output reg [4:0] resultant_p_P1, resultant_p_P2, 
    output reg [1:0] collision_detected
);

// Temporary variables for collision check
reg collision_occurred;
reg [15:0] distance_squared; // Square of the distance between centers
reg [15:0] combined_radii_squared; // Square of combined radii

always @(posedge basys_clock) begin
    collision_detected <= 0;
    resultant_d_P1 <= initial_direction_P1;
    resultant_d_P2 <= initial_direction_P2;
    resultant_p_P1 <= initial_power_P1;
    resultant_p_P2 <= initial_power_P2;

    // Calculate the square of the distance between P1 and P2 centers
    distance_squared <= (x_centre_P1 - x_centre_P2) * (x_centre_P1 - x_centre_P2) +
                        (y_centre_P1 - y_centre_P2) * (y_centre_P1 - y_centre_P2);

    // Calculate the square of the combined radii
    combined_radii_squared <= (P1_radius + P2_radius) * (P1_radius + P2_radius);

    // Check for collision based on distance between centers and combined radii
    if (distance_squared <= combined_radii_squared) begin
        collision_occurred <= 1;
        collision_detected <= 1;
        
        if (initial_power_P1 > initial_power_P2) begin // Case where P1 hits P2
            resultant_p_P2 <= initial_power_P1; // P2 receives P1's power
            resultant_p_P1 <= 0; // P1 stops moving
            resultant_d_P2 <= initial_direction_P1; // P2 takes P1's direction
            resultant_d_P1 <= initial_direction_P1; // P1's direction is set but irrelevant as it stops
        end else begin // Case where P2 hits P1
            resultant_p_P1 <= initial_power_P2; // P1 receives P2's power
            resultant_p_P2 <= 0; // P2 stops moving
            resultant_d_P1 <= initial_direction_P2; // P1 takes P2's direction
            resultant_d_P2 <= initial_direction_P2; // P2's direction is set but irrelevant as it stops
        end
    end else begin
        collision_occurred <= 0;
    end
end

endmodule



// split power in half          
/*module collision_detection_test(
    input basys_clock,
    input [7:0] x_centre_P1, y_centre_P1, 
    input [7:0] x_centre_P2, y_centre_P2,
    input [4:0] initial_direction_P1, initial_direction_P2, 
    input [4:0] initial_power_P1, initial_power_P2, 
    input [7:0] P1_radius, P2_radius, 
    output reg [4:0] resultant_d_P1, resultant_d_P2, 
    output reg [4:0] resultant_p_P1, resultant_p_P2, 
    output reg [1:0] collision_detected
);

reg collision_occurred;
reg [15:0] distance_squared; // Square of the distance between centers
reg [15:0] combined_radii_squared; // Square of combined radii

always @(posedge basys_clock) begin
    collision_detected <= 0;
    resultant_d_P1 <= initial_direction_P1;
    resultant_d_P2 <= initial_direction_P2;
    resultant_p_P1 <= initial_power_P1;
    resultant_p_P2 <= initial_power_P2;

    // Calculate the square of the distance between P1 and P2 centers
    distance_squared <= (x_centre_P1 - x_centre_P2) * (x_centre_P1 - x_centre_P2) +
                        (y_centre_P1 - y_centre_P2) * (y_centre_P1 - y_centre_P2);

    // Calculate the square of the combined radii
    combined_radii_squared <= (P1_radius + P2_radius) * (P1_radius + P2_radius);

    // Check for collision based on distance between centers and combined radii
    if (distance_squared <= combined_radii_squared) begin
        collision_occurred <= 1;
        collision_detected <= 1;
    end else begin
        collision_occurred <= 0;
    end

    // Collision logic for power and direction
    if (collision_occurred) begin
        // Calculate average power
        resultant_p_P1 <= (initial_power_P1 + initial_power_P2) / 2;
        resultant_p_P2 <= (initial_power_P1 + initial_power_P2) / 2;

        // Determine direction based on point of contact
        if (initial_power_P1 > initial_power_P2) begin // P1 hits P2
            resultant_d_P2 <= initial_direction_P1;
            resultant_d_P1 <= (initial_direction_P1 + 8) % 16; // Reflection for P1
        end
        else begin // P2 hits P1
            resultant_d_P1 <= initial_direction_P2;
            resultant_d_P2 <= (initial_direction_P2 + 8) % 16; // Reflection for P2
        end
    end
end

endmodule*/



